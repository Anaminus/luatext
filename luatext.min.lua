return {MakeParser = function(G)
function lku(t) for _,v in pairs(t) do t[v] = true end return t end local WT=lku{' ','\n','\t','\r'};local LC=lku{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};local UC=lku{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};local DG=lku{'0','1','2','3','4','5','6','7','8','9'};local p=1;local gE=error;local function er(e)local l,c=1,1;for pt=1,p do if G:sub(pt,pt)=='\n' then l=l+1;c=0;else c=c+1;end end local lB=p;while lB>0 and G:sub(lB,lB)~='\n' do lB=lB-1 end lB=lB+1;local lE=p;while lE<=(#G) and G:sub(lE,lE)~='\n' do lE=lE+1 end lE=lE-1;local T=G:sub(lB,lE);local o=p-lB;gE("LuaTextError:"..l..":"..c..": "..e..":\n"..T:gsub("\t"," ").."\n"..string.rep(" ",o).."^--Here")end local gP=print;local function pr(...) --[[glbPrint(...)]] end local function white() while WT[G:sub(p,p)] do p=p+1 end end local function eof() return p>#G end local function isWhite(a) a=a or G:sub(p,p);return WT[a] or false;end local function isA(a) a=a or G:sub(p,p);return LC[a] or UC[a] or false;end local function isD(a) a=a or G:sub(p,p);return DG[a] or false;end local function isZ(a) a=a or G:sub(p,p);return isA(a) or isD(a) or (a=='_') or false;end local function is(c) return G:sub(p,p+(#c)-1)==c; end local function g(n) n=n or 1;local s=G:sub(p,p+n-1);p=p+n;return s;end local function pk() return G:sub(p,p);end local function lId() local s=p;while isZ() do p=p+1 end return G:sub(s,p-1);end local function lR() g();local s = p;while isZ() do p=p+1 end local t=G:sub(s,p-1) if not is('>') then er("Expected `>`") end g() return t end local function lL() g();local s=p;while not is('`') do p=p+1 end local t=G:sub(s,p-1);g();return t end local function lE() g();local s=p;while not is('!') do p=p+1 end;local tok=G:sub(s,p-1);g();return tok end local gR = {};local function MPCtx(i)local c = {};c.s = i;c.p = 1;c.c = {};c.w=function() while isWhite(i:sub(c.p,c.p)) do c.p=c.p+1;end end c.pk=function(n) n=n or 1;return i:sub(c.p,c.p+n-1);end c.g=function(n) n=n or 1;local s = i:sub(c.p,c.p+n-1);c.p = c.p+n;return s end return c;end local function MOrR(rs) return function(c)for i,r in pairs(rs) do local o=c.p;local s,m,x=r(c);if s then return s,m,x;end c.p=o;end return false;end end local function MGlobalRefR(n)return function(c) return (gR[n] or gE("Rule <"..n.."> not found."))(c);end end local function MGlobalR(n,h) return function(c)local o=c.c;c.c = nil;local s,m,x=h(c);if s then local r=c.c or x;c.c=o;return s,m,r;else c.c=o;return false;end end end local function MMaybeR(r) return function(c)local o=c.p;local s,m,x=r(c);if s then return s,m,x;else c.p=o;return true,"","";end end end local function MLiteralR(s) return function(c) c.w();if c.s:sub(c.p,c.p+(#s)-1)==s then c.p=c.p+#s;return true,s,s;else return false end end end local function MNumberR() return function(c)c.w();local o=c.p;if c.pk()=='-' then c.g() end while isD(c.pk()) do c.g() end if c.pk()=='.' then c.g(); while isD(c.pk()) do c.g() end end if c.p~=o then local n = c.s:sub(o,c.p-1);return true,n,tonumber(n);else return false;end end end local function MIdentR() return function(c)c.w();local o=c.p;if isA(c.pk()) then while isZ(c.pk())do c.g() end local s = c.s:sub(o,c.p-1);return true,s,s;else return false;end end end local function MStringR() return function(c)c.w();if c.pk()=='"'or c.pk()=="'"then local d=c.g();local o=c.p;while true do if c.p>#c.s then return false; elseif c.pk()==d then local s = c.s:sub(o,c.p-1);c.g();return true,s,s;end c.g(); end else return false end end end local function MWordR() return function(c)c.w();if isZ(c.pk()) then local o=c.p; while isZ(c.pk()) do c.g() end;local s=c.s:sub(o,c.p-1);return true,s,s;else return false;end end end local function MEofR() return function(c)if c.p>#c.s then return true,"","" else return false end end end local function MErrorPointR(e,r) return function(c)local s,m,x = r(c);if not s then gE(e) end return s,m,x;end end local function MRepeatR(r,z) return function(c)local t=c.p;local s,m,x=r(c);if s then while true do local o=c.p;local ns,nm,nx=r(c);if ns then s,m,x=ns,nm,nx;else c.p=o;return true,c.s:sub(t,o-1),x;end end else if z then c.p=t;return true,"","";else return false;end end end end local function MSeriesR(R) return function(c)local s,m,x;local o=c.p;for i,r in pairs(R) do s,m,x=r(c);if not s then c.p=o;return s;end end local s=c.s:sub(o,c.p-1);return true,s,s; end end local function MCaptureR(cp,b) return function(c)local s,m,x=b(c);if s then x=cp.h(c,x);return s,m,x;else return s;end end end local function MExclusiveR(r) return function(c)local o = c.p;while true do local b=c.p;if r(c) then c.p=b;if c.p==o then return false else local s = c.s:sub(o,c.p-1);return true,s,s;end end c.p=b; if c.p>#c.s then return false;end c.p=c.p+1;end end end gR['ident']=MIdentR();gR['number']=MNumberR();gR['string']=MStringR();gR['word']=MWordR();gR['eof']=MEofR();local PCG, PRS, POR, PGR, PG;PCG=function(c)local cp;g();white();if is('}') then cp={type='anon',h=function(c,d) c.c=d;end} elseif is('[') then g();if not is(']')then er("Expected `]`") end;g();cp={type='anon-list',h=function(c,d) c.c=c.c or {};c.c[#c.c+1]=d;end} else local N=lId();white();if is('[') then g();if not is(']') then er("Expected `]`") end;g();cp={type='named-list',h=function(c,d) c.c=c.c or {};if not c.c[N] then c.c[N]={};end local a=c.c[N];a[#a+1]=d;end} elseif is('(') then g();if not is(')') then error("Expected `)`") end;g();cp={type='named-action',h=function(c,d) if not c.a[N] then er("Missing action `"..N.."()`") end return c.a[N](d);end} elseif is('}') then cp={type='named',h=function(c,d) c.c=c.c or {};if not c.c[N] then c.c[N]={};end c.c[N]=d;end}else er("Bad capture")end end white();if not is('}') then er("Expected `}`") end;g();white();if not is('(') then er("Expected `(`") end;g()local r=POR(c);white();if not is(')') then er("Expected `)`") end;g();return MCaptureR(cp,r)end;PRS=function(c)white();local R={};while true do local r=nil;white();if is('{') then r=PCG(c)elseif is('[') then g();r=POR(c);if not is(']') then er("Unfinished maybe block, `]` expected") end;g();r=MMaybeR(r);elseif is('$') then g();if not is('(') then er("Expected `(`") end;g();r=POR(c);if not is(')') then er("Expected `)`") end;g();r=MExclusiveR(r);elseif is('`') then r=MLiteralR(lL());elseif is('(') then g();r=POR(c);if not is(')')then er("Unfinished group block, `)` expected")end;g();elseif is('<') then local N=lR();r=gR[N] or MGlobalRefR(N);elseif is('!') then local e=lE();r=POR(c);r=MErrorPointR(e,r);else break end white();if is('*') then g();r=MRepeatR(r,true) elseif is('+') then g();r=MRepeatR(r,false)end R[#R+1]=r;end if #R>1 then return MSeriesR(R);elseif #R==1 then return R[1];else er("Rule expected") end end;POR=function(c)local C={};white();if is('|') then g();end white();local f=PRS(c);C[#C+1]=f;white();while is('|') do g();C[#C+1]=PRS(c);white()end if #C>1 then return MOrR(C) else return f end end;PGR=function()local c={};white();if not is('<') then er("Expected rule") end local N=lR();white();if not is(':=') then er("Expected `:=`") end g(2);white();local h=POR(c);white();if not is(';')then er("Expected `;` after rule")end g();local r=MGlobalR(N,h);gR[N]=r;return r;end;PG=function() while true do white();if eof() then break end PGR() end end;PG();return function(R,s,a)local r=gR[R];if not r then gE("Base rule `<"..R..">` is missing");end local c=MPCtx(s);c.a=a;local s,m,x=r(c);return x;end
end}
